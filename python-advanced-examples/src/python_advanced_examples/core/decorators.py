"""
Ê†∏ÂøÉË£ÖÈ•∞Âô®Ê®°Âùó

Êèê‰æõÁ≥ªÁªü‰ΩøÁî®ÁöÑÂü∫Á°ÄË£ÖÈ•∞Âô®ÔºåÂåÖÊã¨Á§∫‰æãÊ≥®ÂÜå„ÄÅÊÄßËÉΩÁõëÊéß„ÄÅÂü∫ÂáÜÊµãËØïÁ≠â„ÄÇ
"""

import functools
import logging
from typing import Callable, Optional, Any, Union, List

from .registry import ExampleRegistry, ExampleCategory, DifficultyLevel
from .performance import monitor_performance as _monitor_performance, benchmark as _benchmark

logger = logging.getLogger(__name__)


def example(
    name: str,
    category: Union[ExampleCategory, str],
    difficulty: Union[DifficultyLevel, str] = DifficultyLevel.INTERMEDIATE,
    description: str = "",
    tags: Optional[List[str]] = None,
    **kwargs
) -> Callable:
    """Á§∫‰æãÊ≥®ÂÜåË£ÖÈ•∞Âô®
    
    Â∞ÜÂáΩÊï∞Ê≥®ÂÜå‰∏∫ÂèØËøêË°åÁöÑÁ§∫‰æã„ÄÇ
    
    Args:
        name: Á§∫‰æãÂêçÁß∞ÔºåÁî®‰∫éÊ†áËØÜÂíåËøêË°å
        category: Á§∫‰æãÂàÜÁ±ª
        difficulty: ÈöæÂ∫¶Á∫ßÂà´
        description: Á§∫‰æãÊèèËø∞
        tags: Ê†áÁ≠æÂàóË°®ÔºåÁî®‰∫éÊêúÁ¥¢ÂíåÂàÜÁ±ª
        **kwargs: ÂÖ∂‰ªñÁ§∫‰æãÂ±ûÊÄß
    
    Example:
        @example("basic_decorator", "decorators", "beginner", "Âü∫Á°ÄË£ÖÈ•∞Âô®Á§∫‰æã")
        def basic_decorator_example():
            pass
    """
    def decorator(func: Callable) -> Callable:
        # ‰ΩøÁî®ÂÖ®Â±ÄÊ≥®ÂÜåË°®
        from . import registry
        
        # Ê≥®ÂÜåÁ§∫‰æã
        registry_decorator = registry.register(
            name=name,
            category=category,
            difficulty=difficulty,
            description=description,
            tags=tags,
            **kwargs
        )
        
        # Â∫îÁî®Ê≥®ÂÜåË£ÖÈ•∞Âô®
        registered_func = registry_decorator(func)
        
        # Ê∑ªÂä†‰æøÊç∑ÊñπÊ≥ï
        registered_func.example_name = name
        registered_func.example_category = category
        registered_func.example_difficulty = difficulty
        
        return registered_func
    
    return decorator


def monitor_performance(name: Optional[str] = None):
    """ÊÄßËÉΩÁõëÊéßË£ÖÈ•∞Âô®ÁöÑÂ∞ÅË£Ö"""
    return _monitor_performance(name)


def benchmark(iterations: int = 10, warmup: int = 3):
    """Âü∫ÂáÜÊµãËØïË£ÖÈ•∞Âô®ÁöÑÂ∞ÅË£Ö"""
    return _benchmark(iterations, warmup)


def demo(
    title: str = "",
    description: str = "",
    auto_run: bool = False
) -> Callable:
    """ÊºîÁ§∫Ë£ÖÈ•∞Âô®
    
    Ê†áËÆ∞ÂáΩÊï∞‰∏∫ÊºîÁ§∫Áî®ÈÄîÔºåÊèê‰æõÈ¢ùÂ§ñÁöÑÂ±ïÁ§∫‰ø°ÊÅØ„ÄÇ
    
    Args:
        title: ÊºîÁ§∫Ê†áÈ¢ò
        description: ÊºîÁ§∫ÊèèËø∞
        auto_run: ÊòØÂê¶Ëá™Âä®ËøêË°åÔºàÁî®‰∫éWebÁïåÈù¢Ôºâ
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if title:
                print(f"\nüéØ {title}")
                print("=" * (len(title) + 4))
            
            if description:
                print(f"üìù {description}\n")
            
            try:
                result = func(*args, **kwargs)
                
                if title:
                    print(f"\n‚úÖ {title} ÂÆåÊàê")
                
                return result
            
            except Exception as e:
                if title:
                    print(f"\n‚ùå {title} Â§±Ë¥•: {e}")
                raise
        
        # Ê∑ªÂä†ÊºîÁ§∫ÂÖÉÊï∞ÊçÆ
        wrapper._demo_metadata = {
            "title": title or func.__name__,
            "description": description,
            "auto_run": auto_run
        }
        
        return wrapper
    
    return decorator


def safe_execution(
    catch_exceptions: bool = True,
    log_errors: bool = True,
    default_return: Any = None,
    reraise: bool = False
) -> Callable:
    """ÂÆâÂÖ®ÊâßË°åË£ÖÈ•∞Âô®
    
    ‰∏∫ÂáΩÊï∞Êèê‰æõÂºÇÂ∏∏Â§ÑÁêÜÂíåÈîôËØØÊÅ¢Â§çÊú∫Âà∂„ÄÇ
    
    Args:
        catch_exceptions: ÊòØÂê¶ÊçïËé∑ÂºÇÂ∏∏
        log_errors: ÊòØÂê¶ËÆ∞ÂΩïÈîôËØØÊó•Âøó
        default_return: ÂºÇÂ∏∏Êó∂ÁöÑÈªòËÆ§ËøîÂõûÂÄº
        reraise: ÊòØÂê¶ÈáçÊñ∞ÊäõÂá∫ÂºÇÂ∏∏
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                if log_errors:
                    logger.error(f"Error in {func.__name__}: {e}", exc_info=True)
                
                if reraise:
                    raise
                
                if catch_exceptions:
                    return default_return
                else:
                    raise
        
        return wrapper
    
    return decorator


def validation(
    validate_args: bool = True,
    validate_kwargs: bool = True,
    type_check: bool = False
) -> Callable:
    """ÂèÇÊï∞È™åËØÅË£ÖÈ•∞Âô®
    
    ‰∏∫ÂáΩÊï∞Êèê‰æõÂèÇÊï∞È™åËØÅÂäüËÉΩ„ÄÇ
    
    Args:
        validate_args: ÊòØÂê¶È™åËØÅ‰ΩçÁΩÆÂèÇÊï∞
        validate_kwargs: ÊòØÂê¶È™åËØÅÂÖ≥ÈîÆÂ≠óÂèÇÊï∞
        type_check: ÊòØÂê¶ËøõË°åÁ±ªÂûãÊ£ÄÊü•
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if type_check:
                # ÁÆÄÂçïÁöÑÁ±ªÂûãÊ£ÄÊü•ÂÆûÁé∞
                import inspect
                sig = inspect.signature(func)
                bound_args = sig.bind(*args, **kwargs)
                bound_args.apply_defaults()
                
                for param_name, param_value in bound_args.arguments.items():
                    param = sig.parameters[param_name]
                    if param.annotation != inspect.Parameter.empty:
                        expected_type = param.annotation
                        if not isinstance(param_value, expected_type):
                            raise TypeError(
                                f"Parameter '{param_name}' expected {expected_type.__name__}, "
                                f"got {type(param_value).__name__}"
                            )
            
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator


def deprecated(
    message: str = "",
    version: str = "",
    replacement: str = ""
) -> Callable:
    """ÂºÉÁî®Ë≠¶ÂëäË£ÖÈ•∞Âô®
    
    Ê†áËÆ∞ÂáΩÊï∞‰∏∫Â∑≤ÂºÉÁî®ÔºåÂπ∂Êèê‰æõË≠¶Âëä‰ø°ÊÅØ„ÄÇ
    
    Args:
        message: ÂºÉÁî®Ê∂àÊÅØ
        version: ÂºÉÁî®ÁâàÊú¨
        replacement: Êé®ËçêÁöÑÊõø‰ª£ÊñπÊ°à
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import warnings
            
            warning_msg = f"Function '{func.__name__}' is deprecated"
            
            if version:
                warning_msg += f" since version {version}"
            
            if replacement:
                warning_msg += f". Use '{replacement}' instead"
            
            if message:
                warning_msg += f". {message}"
            
            warnings.warn(warning_msg, DeprecationWarning, stacklevel=2)
            
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator


def experimental(
    message: str = "This feature is experimental and may change in future versions"
) -> Callable:
    """ÂÆûÈ™åÊÄßÂäüËÉΩË£ÖÈ•∞Âô®
    
    Ê†áËÆ∞ÂáΩÊï∞‰∏∫ÂÆûÈ™åÊÄßÂäüËÉΩ„ÄÇ
    
    Args:
        message: ÂÆûÈ™åÊÄßÂäüËÉΩË≠¶ÂëäÊ∂àÊÅØ
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import warnings
            
            warning_msg = f"Function '{func.__name__}' is experimental. {message}"
            warnings.warn(warning_msg, UserWarning, stacklevel=2)
            
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator


def requires_dependencies(*dependencies: str):
    """‰æùËµñÊ£ÄÊü•Ë£ÖÈ•∞Âô®
    
    Ê£ÄÊü•ÂáΩÊï∞ËøêË°åÊâÄÈúÄÁöÑ‰æùËµñÊòØÂê¶ÂèØÁî®„ÄÇ
    
    Args:
        dependencies: ÂøÖÈúÄÁöÑ‰æùËµñÂåÖÂêçÂàóË°®
    """
    def decorator(func: Callable) -> Callable:
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            missing_deps = []
            
            for dep in dependencies:
                try:
                    __import__(dep)
                except ImportError:
                    missing_deps.append(dep)
            
            if missing_deps:
                raise ImportError(
                    f"Function '{func.__name__}' requires the following dependencies: "
                    f"{', '.join(missing_deps)}. Please install them first."
                )
            
            return func(*args, **kwargs)
        
        # Ê∑ªÂä†‰æùËµñ‰ø°ÊÅØÂà∞ÂáΩÊï∞
        wrapper._required_dependencies = dependencies
        
        return wrapper
    
    return decorator


def log_calls(
    logger_name: Optional[str] = None,
    log_args: bool = False,
    log_result: bool = False,
    log_duration: bool = True
) -> Callable:
    """ÂáΩÊï∞Ë∞ÉÁî®Êó•ÂøóË£ÖÈ•∞Âô®
    
    ËÆ∞ÂΩïÂáΩÊï∞Ë∞ÉÁî®ÁöÑËØ¶ÁªÜ‰ø°ÊÅØ„ÄÇ
    
    Args:
        logger_name: Êó•ÂøóÂô®ÂêçÁß∞
        log_args: ÊòØÂê¶ËÆ∞ÂΩïÂèÇÊï∞
        log_result: ÊòØÂê¶ËÆ∞ÂΩïËøîÂõûÂÄº
        log_duration: ÊòØÂê¶ËÆ∞ÂΩïÊâßË°åÊó∂Èó¥
    """
    def decorator(func: Callable) -> Callable:
        func_logger = logging.getLogger(logger_name or func.__module__)
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            import time
            
            start_time = time.time()
            
            # ËÆ∞ÂΩïË∞ÉÁî®ÂºÄÂßã
            call_info = f"Calling {func.__name__}"
            if log_args and (args or kwargs):
                call_info += f" with args={args}, kwargs={kwargs}"
            
            func_logger.debug(call_info)
            
            try:
                result = func(*args, **kwargs)
                
                # ËÆ∞ÂΩïË∞ÉÁî®ÂÆåÊàê
                end_time = time.time()
                duration = end_time - start_time
                
                complete_info = f"Completed {func.__name__}"
                if log_duration:
                    complete_info += f" in {duration:.3f}s"
                if log_result:
                    complete_info += f" with result={result}"
                
                func_logger.debug(complete_info)
                
                return result
                
            except Exception as e:
                end_time = time.time()
                duration = end_time - start_time
                
                error_info = f"Failed {func.__name__} after {duration:.3f}s with error: {e}"
                func_logger.error(error_info)
                
                raise
        
        return wrapper
    
    return decorator


def memoize(maxsize: int = 128):
    """ËÆ∞ÂøÜÂåñË£ÖÈ•∞Âô®
    
    ÁºìÂ≠òÂáΩÊï∞ÁªìÊûú‰ª•ÊèêÈ´òÊÄßËÉΩ„ÄÇ
    
    Args:
        maxsize: ÁºìÂ≠òÁöÑÊúÄÂ§ßÂ§ßÂ∞è
    """
    def decorator(func: Callable) -> Callable:
        @functools.lru_cache(maxsize=maxsize)
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # lru_cacheÂè™ÊîØÊåÅhashableÂèÇÊï∞ÔºåËøôÈáåÂè™Â§ÑÁêÜÂü∫Êú¨ÊÉÖÂÜµ
            return func(*args, **kwargs)
        
        # Ê∑ªÂä†ÁºìÂ≠òÁÆ°ÁêÜÊñπÊ≥ï
        wrapper.cache_clear = wrapper.cache_clear
        wrapper.cache_info = wrapper.cache_info
        
        return wrapper
    
    return decorator


def rate_limit(calls_per_second: float = 1.0):
    """ÈÄüÁéáÈôêÂà∂Ë£ÖÈ•∞Âô®
    
    ÈôêÂà∂ÂáΩÊï∞ÁöÑË∞ÉÁî®È¢ëÁéá„ÄÇ
    
    Args:
        calls_per_second: ÊØèÁßíÂÖÅËÆ∏ÁöÑË∞ÉÁî®Ê¨°Êï∞
    """
    def decorator(func: Callable) -> Callable:
        import time
        import threading
        
        lock = threading.Lock()
        last_call_time = [0.0]  # ‰ΩøÁî®ÂàóË°®‰ª•ÊîØÊåÅ‰øÆÊîπ
        min_interval = 1.0 / calls_per_second
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with lock:
                current_time = time.time()
                time_since_last_call = current_time - last_call_time[0]
                
                if time_since_last_call < min_interval:
                    sleep_time = min_interval - time_since_last_call
                    time.sleep(sleep_time)
                
                last_call_time[0] = time.time()
            
            return func(*args, **kwargs)
        
        return wrapper
    
    return decorator